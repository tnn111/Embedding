#!/usr/bin/env -S uv run --quiet --script
"""
Generate VAE latent embeddings from k-mer frequency data.
Pure filter: reads stdin, writes stdout, messages to stderr.

Input: NumPy array from stdin (from calculate_kmer_frequencies)
    2,773 columns: length + 6-mers(2080) + 5-mers(512) + 4-mers(136) + 3-mers(32) + 2-mers(10) + 1-mers(2)

Output: NumPy array with 385 columns (length + latent embeddings z_mean)

Usage:
    cat input.npy | embedding > embeddings.npy
    embedding < input.npy > embeddings.npy
"""
# /// script
# dependencies = [
#   "numpy",
#   "keras",
#   "jax[cuda12]",
# ]
# ///

import sys
import os
os.environ['KERAS_BACKEND'] = 'jax'
os.environ['XLA_PYTHON_CLIENT_PREALLOCATE'] = 'false'

import numpy as np
import keras
import io


# Custom layers required for loading the encoder
SEED = 42


@keras.saving.register_keras_serializable()
class ClipLayer(keras.layers.Layer):
    """Clips tensor values to a specified range."""

    def __init__(self, min_value = -20, max_value = 2, **kwargs):
        super().__init__(**kwargs)
        self.min_value = min_value
        self.max_value = max_value

    def call(self, inputs):
        return keras.ops.clip(inputs, self.min_value, self.max_value)

    def get_config(self):
        config = super().get_config()
        config.update({'min_value': self.min_value, 'max_value': self.max_value})
        return config


@keras.saving.register_keras_serializable()
class Sampling(keras.layers.Layer):
    """Reparameterization trick: sample z = mean + exp(log_var/2) * epsilon."""

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.seed_generator = keras.random.SeedGenerator(SEED)

    def call(self, inputs):
        z_mean, z_log_var = inputs
        batch = keras.ops.shape(z_mean)[0]
        dim = keras.ops.shape(z_mean)[1]
        epsilon = keras.random.normal(shape = (batch, dim), seed = self.seed_generator)
        return z_mean + keras.ops.exp(0.5 * z_log_var) * epsilon

    def get_config(self):
        return super().get_config()


# Column ranges in k-mers.npy (new format: col 0 = length, cols 1-2772 = k-mers)
COL_KMER_START = 1
COL_KMER_END = 2773


KMER_SLICES = [
    (0, 2080),       # 6-mer
    (2080, 2592),    # 5-mer
    (2592, 2728),    # 4-mer
    (2728, 2760),    # 3-mer
    (2760, 2770),    # 2-mer
    (2770, 2772),    # 1-mer
]


def clr_transform(data: np.ndarray) -> np.ndarray:
    """Apply per-group Centered Log-Ratio (CLR) transformation.

    Each k-mer size group is CLR-transformed independently, since
    each group is separately normalized to sum to 1.0. Uses a Jeffreys
    prior pseudocount of 0.5/n_features per group.
    """
    data = data.copy()
    for start, end in KMER_SLICES:
        group = data[:, start:end]
        pseudocount = 0.5 / (end - start)
        group += pseudocount
        np.log(group, out = group)
        log_geom_mean = np.mean(group, axis = 1, keepdims = True)
        group -= log_geom_mean
    return data


def main():
    # Load encoder
    print('Loading encoder...', file = sys.stderr)
    encoder = keras.saving.load_model(
        'vae_encoder_best.keras',
        custom_objects = {'ClipLayer': ClipLayer, 'Sampling': Sampling}
    )

    # Read numpy array from stdin
    print('Loading data from stdin...', file = sys.stderr)
    raw_data = np.load(sys.stdin.buffer)

    # Extract length (column 0) and k-mer features (columns 1-2772)
    lengths = raw_data[:, 0:1]  # Keep as 2D for concatenation
    kmer_data = raw_data[:, COL_KMER_START:COL_KMER_END].astype(np.float32)

    # Apply CLR transformation
    print('Applying CLR transformation...', file = sys.stderr)
    kmer_data = clr_transform(kmer_data)

    print(f'Loaded {kmer_data.shape[0]} sequences with {kmer_data.shape[1]} features', file = sys.stderr)

    # Get embeddings
    print('Generating embeddings...', file = sys.stderr)
    z_mean, z_log_var, z = encoder.predict(kmer_data, batch_size = 8192, verbose = 0)

    # Concatenate length with embeddings
    output = np.concatenate([lengths, z_mean], axis = 1)

    print(f'Output shape: {output.shape}', file = sys.stderr)

    # Write to stdout as NumPy binary format
    buffer = io.BytesIO()
    np.save(buffer, output)
    buffer.seek(0)
    sys.stdout.buffer.write(buffer.read())

    print('Done', file = sys.stderr)


if __name__ == '__main__':
    main()
