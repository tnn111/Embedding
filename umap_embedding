#!/usr/bin/env python
# /// script
# dependencies = [
#   'numpy',
#   'umap-learn',
#   'hdbscan',
#   'cuml-cu12',
# ]
# ///

import  argparse
import  numpy as np
import  hdbscan

# Parse command-line arguments
parser = argparse.ArgumentParser(description='Run UMAP embedding with GPU/CPU support')
parser.add_argument('-j', '--jobs', type=int, default=8, help='Number of parallel jobs for CPU version (default: 8)')
parser.add_argument('-n', '--neighbors', type=int, default=15, help='Number of neighbors for UMAP (default: 15)')
parser.add_argument('-i', '--input', type=str, required=True, help='Input file path for k-mer frequencies')
parser.add_argument('-o', '--output', type=str, required=True, help='Output file path for UMAP embedding')
args = parser.parse_args()

# Try to use GPU-accelerated UMAP, fall back to CPU if unavailable
try:
    from cuml import UMAP
    print('Using GPU-accelerated UMAP (cuML)')
    use_gpu = True
except ImportError:
    from umap import UMAP
    print('Using CPU-based UMAP (umap-learn)')
    use_gpu = False


X_freq = np.loadtxt(args.input, dtype=np.float32)
# X_freq = X_freq[:100000]  # Uncomment to test with 100K sequences first

print(f"Loaded {X_freq.shape[0]} sequences")
print(f"Sum check: {X_freq[0].sum():.6f}")

# Configure UMAP parameters based on GPU/CPU
if use_gpu:
    # GPU version (cuML) - different parameter set
    reducer = UMAP(
        n_components = 32,
        metric = 'cosine',
        n_neighbors = args.neighbors,
        min_dist = 0.0,
        verbose = True
    )
else:
    # CPU version (umap-learn) - includes parallelism and memory options
    reducer = UMAP(
        n_components = 32,
        metric = 'cosine',
        n_neighbors = args.neighbors,
        min_dist = 0.0,
        n_jobs = args.jobs,
        low_memory = True,
        verbose = True
    )

embedding = reducer.fit_transform(X_freq)
np.save(args.output, embedding)
print(f'Saved embedding to {args.output}')